¬°Claro que s√≠\! Ha sido un buen ejercicio de depuraci√≥n.

Aqu√≠ tienes una explicaci√≥n detallada de cada parte del c√≥digo final (Dockerfile y entrypoint.sh) y por qu√© ahora s√≠ funciona todo junto.

-----

## 1\. El Dockerfile (El Plano de la Imagen) üìÑ

El Dockerfile es como una *receta de cocina* que le dice a Docker c√≥mo construir una imagen. Se ejecuta una sola vez, durante el docker build.

dockerfile
# 1. Imagen base
FROM ubuntu:22.04


*Qu√© hace:* Empieza desde una imagen limpia de Ubuntu 22.04.

dockerfile
# 2. Configurar entorno para instalaci√≥n no interactiva
ENV DEBIAN_FRONTEND=noninteractive


*Qu√© hace:* Evita que los instaladores (como apt-get) se detengan a hacerte preguntas (ej. "¬øQu√© zona horaria quieres?").

dockerfile
# 3. Argumentos de build (...)
ARG DB_USER=admin
ARG DB_PASS=admin123
ARG SSH_PASS=sshpass123
ARG MYSQL_PORT=3307
ARG PG_PORT=5433


*Qu√© hace:* Define variables que puedes cambiar solo en el momento de construir la imagen (con docker build --build-arg ...). Si no especificas nada, usa estos valores por defecto.

dockerfile
# 4. Actualizar e instalar todo el software necesario
RUN apt-get update && apt-get install -y ...


*Qu√© hace:* Instala todo el software que necesitamos (SSH, MySQL, Postgres, etc.) en una sola capa de la imagen para ahorrar espacio.

dockerfile
# 5. Configurar SSH
RUN mkdir /var/run/sshd
RUN echo "root:${SSH_PASS}" | chpasswd
RUN sed -i 's/#PermitRootLogin prohibit-password/PermitRootLogin yes/' ...


*Qu√© hace:* Prepara el servidor SSH. Crea una carpeta que necesita, establece la contrase√±a de root (usando el ARG) y modifica el fichero de configuraci√≥n para permitir que root inicie sesi√≥n.

dockerfile
# 6. Configurar MySQL (La parte CLAVE)
# 1. Borramos cualquier l√≠nea existente de 'bind-address' y 'port'
RUN sed -i "/^#\?bind-address/d" /etc/mysql/mysql.conf.d/mysqld.cnf && \
    sed -i "/^#\?port/d" /etc/mysql/mysql.conf.d/mysqld.cnf && \
# 2. A√±adimos las l√≠neas correctas bajo [mysqld]
    sed -i "/\[mysqld\]/a bind-address = 0.0.0.0" ... && \
    sed -i "/\[mysqld\]/a port = ${MYSQL_PORT}" ...


*Qu√© hace:* Aqu√≠ est√° la soluci√≥n a nuestros problemas. Es un m√©todo de 2 pasos:

1.  **Borrar (/d): sed -i "/^#\?bind-address/d" busca cualquier l√≠nea que empiece (^) con bind-address (o #bind-address, por eso el #\?) y la *borra* (d). Hacemos lo mismo para port.
2.  **A√±adir (/a): sed -i "/\[mysqld\]/a ..." busca la cabecera [mysqld] y *a√±ade* (append) nuestras l√≠neas de configuraci√≥n correctas (bind-address = 0.0.0.0 y port = 3307) justo debajo.

As√≠ nos aseguramos de que no hay configuraciones duplicadas y que las nuestras son las √∫nicas que se leen.

dockerfile
# Crear el usuario de MySQL en tiempo de construcci√≥n
RUN service mysql start && \
    sleep 5 && \
    mysql -e "CREATE USER '${DB_USER}'@'%' ..." && \
    service mysql stop


*Qu√© hace:* Esto se ejecuta *durante el build*. Inicia el servicio de MySQL temporalmente, crea el usuario y la contrase√±a (usando los ARG), y luego lo vuelve a parar. Los datos del usuario quedan guardados en la imagen.

dockerfile
# 7. Configurar PostgreSQL
RUN PG_VERSION=$(ls /etc/postgresql/ | head -n 1) && \
    ...


*Qu√© hace:* Similar a MySQL. Configura Postgres para que escuche en todas las interfaces (listen_addresses = '*') y en el puerto 5433. Tambi√©n modifica pg_hba.conf para permitir conexiones externas con contrase√±a. Luego, al igual que con MySQL, inicia el servicio temporalmente para crear el usuario.

dockerfile
# 8. Script de Entrada (NUEVO)
COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh


*Qu√© hace:*

1.  **COPY**: Copia el script entrypoint.sh de tu m√°quina local al interior de la imagen, en la ra√≠z (/).
2.  **chmod +x**: Da permisos de ejecuci√≥n al script, para que pueda ser ejecutado.

<!-- end list -->

dockerfile
# 9. Exponer Puertos (usando los ARGs)
EXPOSE 22
EXPOSE ${MYSQL_PORT}
EXPOSE ${PG_PORT}


*Qu√© hace:* Es una "documentaci√≥n" para Docker. Le dice que el contenedor espera recibir tr√°fico en estos puertos. No los abre por s√≠ solo, por eso necesitamos -p en el docker run.

dockerfile
# 10. ENTRYPOINT (NUEVO)
ENTRYPOINT ["/entrypoint.sh"]


*Qu√© hace:* Esta es la instrucci√≥n m√°s importante. Le dice a Docker: "Cuando alguien inicie este contenedor (docker run), ignora todo lo dem√°s y *ejecuta este script* (/entrypoint.sh) como el proceso principal".

-----

## 2\. El entrypoint.sh (El Guion de Arranque) üöÄ

Este script *se ejecuta CADA VEZ que el contenedor se inicia* (docker run). Su trabajo es arrancar los servicios y mantener el contenedor vivo.

bash
#!/bin/bash
echo "Iniciando script de entrada..."


*Qu√© hace:* #!/bin/bash (shebang) le dice al sistema que use bash para ejecutar el script.

bash
# 1. Arreglar el socket de MySQL
echo "Creando directorio para socket MySQL..."
mkdir -p /var/run/mysqld
chown mysql:mysql /var/run/mysqld


*Qu√© hace:* Esta es la soluci√≥n al segundo gran problema. El directorio /var/run es temporal (tmpfs)
 y *se borra cada vez que el contenedor se reinicia*. MySQL necesita /var/run/mysqld para su fichero
 "socket". Este comando vuelve a crear la carpeta y le da los permisos correctos *en cada arranque*,
 permitiendo que service mysql start funcione.

bash
# 2. Iniciar los servicios
echo "Iniciando PostgreSQL..."
service postgresql start

echo "Iniciando MySQL..."
service mysql start

echo "Iniciando SSH..."
service ssh start


*Qu√© hace:* Inicia los tres servicios que instalamos. Ahora s√≠, los servicios est√°n corriendo dentro del contenedor.

bash
# 3. Mantener el contenedor vivo
tail -f /dev/null


*Qu√© hace:* Esta es la clave final. Un contenedor de Docker se mantiene vivo mientras su proceso principal 
(ENTRYPOINT) est√© vivo.

  * Si el script simplemente terminara, Docker dir√≠a "El script ha terminado, el trabajo est√° hecho"
  y *apagar√≠a el contenedor* (y con √©l, todas tus bases de datos).
  * tail -f /dev/null es un truco com√∫n: es un comando que "sigue" (-f) un fichero que nunca escribe nada
  (/dev/null). Es un bucle infinito que no consume CPU y su √∫nico prop√≥sito es *mantener el script 
  (y, por tanto, el contenedor) corriendo¬†para¬†siempre*